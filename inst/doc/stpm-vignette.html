<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>  %\VignetteEncoding{UTF-8}</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>

<!-- MathJax scripts -->
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<hr/>

<p>title: &ldquo;Stochastic Process Model for Analysis of Longitudinal and Time-to-Event Outcomes&rdquo;
author: &ldquo;Ilya Y. Zhbannikov&rdquo;
date: &ldquo;2017-03-04&rdquo;
output: rmarkdown::html_document
vignette: &gt;</p>

<p>%\VignetteIndexEntry{stpm}
  %\VignetteEngine{knitr::rmarkdown}
  usepackage[utf8]{inputenc}</p>

<h2>  %\VignetteEncoding{UTF-8}</h2>

<h2>Overview</h2>

<p>The Stochastic Process Model (SPM) was developed several decades ago [1,2], and applied for analyses of clinical, demographic, epidemiologic longitudinal data as well as in many other studies that relate stochastic dynamics of repeated measures to the probability of end-points (outcomes). SPM links the dynamic of stochastical variables with a hazard rate as a quadratic function of the state variables [3]. The R-package, &ldquo;stpm&rdquo;, is a set of utilities to estimate parameters of stochastic process and modeling survival trajectories and time-to-event outcomes observed from longitudinal studies. It is a general framework for studying and modeling survival (censored) traits depending on random trajectories (stochastic paths) of variables.</p>

<h2>Installation</h2>

<h3>Stable version from CRAN</h3>

<pre><code class="r">install.packages(&quot;stpm&quot;)
</code></pre>

<h3>Most-recent version from GitHub</h3>

<pre><code class="r">require(devtools)
devtools::install_github(&quot;izhbannikov/stpm&quot;)
</code></pre>

<h2>Data description</h2>

<p>Data represents a typical longitudinal data in form of two datasets: longitudinal dataset (follow-up studies), in which one record represents a single observation, and vital (survival) statistics, where one record represents all information about the subject. Longitudinal dataset cat contain a subject ID (identification number), status (event(1)/censored(0)), time and measurements across the variables. The <code>stpm</code> can handle an infinite number of variables but in practice, 5-7 variables is enough.</p>

<p>Below there is an example of clinical data that can be used in <code>stpm</code> and we will discuss the fields later.</p>

<p>Longitudinal table:</p>

<pre><code>##   ID IndicatorDeath Age      DBP      BMI
## 1  1              0  30 80.00000 25.00000
## 2  1              0  32 80.51659 26.61245
## 3  1              0  34 77.78412 29.16790
## 4  1              0  36 77.86665 32.40359
## 5  1              0  38 96.55673 31.92014
## 6  1              0  40 94.48616 32.89139
</code></pre>

<h4>Description of data fields</h4>

<ul>
<li>ID - subject unique identificatin number.</li>
<li>IndicatorDeath - 0/1, indicates death of a subject.</li>
<li>Age - current age of subject at observation.</li>
<li>DBP, BMI - covariates, here &ldquo;DBP&rdquo; represents a diastolic blood pressure, &ldquo;BMI&rdquo; a body-mass index.</li>
</ul>

<h2>Discrete- and continuous-time models</h2>

<p>There are two main SPM types in the package: discrete-time model [4] and continuous-time model [3]. Discrete model assumes equal intervals between follow-up observations. The example of discrete dataset is given below.</p>

<pre><code class="r">library(stpm)
data &lt;- simdata_discr(N=10) # simulate data for 10 individuals
head(data)
</code></pre>

<pre><code>##      id xi t1 t2       y1  y1.next
## [1,]  1  0 30 31 80.00000 73.63661
## [2,]  1  0 31 32 73.63661 75.37150
## [3,]  1  0 32 33 75.37150 74.84731
## [4,]  1  0 33 34 74.84731 70.77146
## [5,]  1  0 34 35 70.77146 75.14526
## [6,]  1  0 35 36 75.14526 73.99116
</code></pre>

<p>In this case there are equal intervals between \(t_1\) and \(t_2\).</p>

<p>In the continuous-time SPM, in which intervals between observations are not equal (arbitrary or random). The example of such dataset is shown below:</p>

<pre><code class="r">library(stpm)
data &lt;- simdata_cont(N=5) # simulate data for 5 individuals
head(data)
</code></pre>

<pre><code>##      id xi       t1       t2       y1  y1.next
## [1,]  0  0 37.05335 38.12137 79.90256 77.35609
## [2,]  0  0 38.12137 39.74058 77.35609 75.33056
## [3,]  0  0 39.74058 41.60331 75.33056 80.93832
## [4,]  0  0 41.60331 43.36223 80.93832 82.79859
## [5,]  0  0 43.36223 44.57398 82.79859 85.08410
## [6,]  0  0 44.57398 45.97303 85.08410 83.77681
</code></pre>

<h3>Discrete-time model</h3>

<p>The discrete model assumes fixed time intervals between consecutive observations. In this model, \(\mathbf{Y}(t)\) (a \(k \times 1\) matrix of the values of covariates, where \(k\) is the number of considered covariates) and \(\mu(t, \mathbf{Y}(t))\) (the hazard rate) have the following form:</p>

<p>\(\mathbf{Y}(t+1) = \mathbf{u} + \mathbf{R} \mathbf{Y}(t) + \mathbf{\epsilon}\)</p>

<p>\(\mu (t, \mathbf{Y}(t)) = [\mu_0 + \mathbf{b} \mathbf{Y}(t) + \mathbf{Y}(t)^* \mathbf{Q} \mathbf{Y}(t)] e^{\theta t}\)</p>

<p>Coefficients \(\mathbf{u}\) (a \(k \times 1\) matrix, where \(k\) is a number of covariates), \(\mathbf{R}\) (a \(k \times k\) matrix), \(\mu_0\), \(\mathbf{b}\) (a \(1 \times k\) matrix), \(\mathbf{Q}\) (a \(k \times k\) matrix) are assumed to be constant in the particular implementation of this model in the R-package <code>stpm</code>. \(\mathbf{\epsilon}\) are normally-distributed random residuals, \(k \times 1\) matrix. A symbol &#39;*&#39; denotes transpose operation. \(\theta\) is a parameter to be estimated along with other parameters (\(\mathbf{u}\), \(\mathbf{R}\), \(\mathbf{\mu_0}\), \(\mathbf{b}\), \(\mathbf{Q}\)).</p>

<h4>Example</h4>

<pre><code class="r">library(stpm)
#Data simulation (200 individuals)
data &lt;- simdata_discr(N=100)
#Estimation of parameters
pars &lt;- spm_discrete(data)
pars
</code></pre>

<pre><code>## $Ak2005
## $Ak2005$theta
## [1] 0.07
## 
## $Ak2005$mu0
## [1] 0.0003429978417
## 
## $Ak2005$b
## [1] -8.537686341e-06
## 
## $Ak2005$Q
##                 [,1]
## [1,] 5.635020239e-08
## 
## $Ak2005$u
## [1] 3.661216818
## 
## $Ak2005$R
##              [,1]
## [1,] 0.9539147914
## 
## $Ak2005$Sigma
## [1] 5.086365468
## 
## 
## $Ya2007
## $Ya2007$a
##                [,1]
## [1,] -0.04608520863
## 
## $Ya2007$f1
##             [,1]
## [1,] 79.44451001
## 
## $Ya2007$Q
##                 [,1]
## [1,] 5.635020239e-08
## 
## $Ya2007$f
##             [,1]
## [1,] 75.75559606
## 
## $Ya2007$b
##             [,1]
## [1,] 5.086365468
## 
## $Ya2007$mu0
##                 [,1]
## [1,] 1.960908283e-05
## 
## $Ya2007$theta
## [1] 0.07
## 
## 
## attr(,&quot;class&quot;)
## [1] &quot;spm.discrete&quot;
</code></pre>

<h3>Continuous-time model</h3>

<p>In the specification of the SPM described in 2007 paper by Yashin and collegaues [3] the stochastic differential equation describing the age dynamics of a covariate is:</p>

<p>\(d\mathbf{Y}(t)= \mathbf{a}(t)(\mathbf{Y}(t) -\mathbf{f}_1(t))dt + \mathbf{b}(t)d\mathbf{W}(t), \mathbf{Y}(t=t_0)\)</p>

<p>In this equation, \(\mathbf{Y}(t)\) (a \(k \times 1\) matrix) is the value of a particular covariate at a time (age) \(t\). \(\mathbf{f}_1(t)\) (a \(k \times 1\) matrix) corresponds to the long-term mean value of the stochastic process \(\mathbf{Y}(t)\), which describes a trajectory of individual covariate influenced by different factors represented by a random Wiener process \(\mathbf{W}(t)\). Coefficient \(\mathbf{a}(t)\) (a \(k \times k\) matrix) is a negative feedback coefficient, which characterizes the rate at which the process reverts to its mean. 
In the area of research on aging, \(\mathbf{f}_1(t)\) represents the mean allostatic trajectory and \(\mathbf{a}(t)\) represents the adaptive capacity of the organism. Coefficient \(\mathbf{b}(t)\) (a \(k \times 1\) matrix) characterizes a strength of the random disturbances from Wiener process \(\mathbf{W}(t)\).</p>

<p>The following function \(\mu(t, \mathbf{Y}(t))\) represents a hazard rate:</p>

<p>\(\mu(t, \mathbf{Y}(t)) = \mu_0(t) + (\mathbf{Y}(t) - \mathbf{f}(t))^* \mathbf{Q}(t) (\mathbf{Y}(t) - \mathbf{f}(t))\)</p>

<p>here \(\mu_0(t)\) is the baseline hazard, which represents a risk when \(\mathbf{Y}(t)\) follows its optimal trajectory; \(\mathbf{f}(t)\) (a \(k \times 1\) matrix) represents the optimal trajectory that minimizes the risk and \(\mathbf{Q}(t)\) (\(k \times k\) matrix) represents a sensitivity of risk function to deviation from the norm.</p>

<h4>Example</h4>

<pre><code class="r">library(stpm)
#Simulate some data for 50 individuals
data &lt;- simdata_cont(N=50)
head(data)
</code></pre>

<pre><code>##      id xi          t1          t2           y1      y1.next
## [1,]  0  0 39.76113951 41.30726533  79.72822330  87.00323548
## [2,]  0  0 41.30726533 43.18509904  87.00323548  81.82371620
## [3,]  0  0 43.18509904 44.51547313  81.82371620  89.52459240
## [4,]  0  0 44.51547313 46.40415120  89.52459240  95.66847831
## [5,]  0  0 46.40415120 48.06325839  95.66847831 101.49024136
## [6,]  0  0 48.06325839 49.92410641 101.49024136  94.58368894
</code></pre>

<pre><code class="r">#Estimate parameters
# a=-0.05, f1=80, Q=2e-8, f=80, b=5, mu0=2e-5, theta=0.08 are starting values for estimation procedure
pars &lt;- spm_continuous(dat=data,a=-0.05, f1=80, Q=2e-8, f=80, b=5, mu0=2e-5, theta=0.08)
pars
</code></pre>

<pre><code>## $a
##                [,1]
## [1,] -0.05250309889
## 
## $f1
##             [,1]
## [1,] 81.85920376
## 
## $Q
##                 [,1]
## [1,] 2.195127693e-08
## 
## $f
##             [,1]
## [1,] 87.99796627
## 
## $b
##             [,1]
## [1,] 5.105003762
## 
## $mu0
## [1] 2.199279838e-05
## 
## $theta
## [1] 0.08494957038
## 
## $status
## [1] 5
## 
## $LogLik
## [1] -6941.024029
## 
## $objective
## [1] 6941.014415
## 
## $message
## [1] &quot;NLOPT_MAXEVAL_REACHED: Optimization stopped because maxeval (above) was reached.&quot;
## 
## $limit
## [1] FALSE
## 
## attr(,&quot;class&quot;)
## [1] &quot;spm.continuous&quot;
</code></pre>

<h3>Coefficient conversion between continuous- and discrete-time models</h3>

<p>The coefficient conversion between continuous- and discrete-time models is as follows (&#39;c&#39; and &#39;d&#39; denote continuous- and discrete-time models respectively; note: these equations can be used if intervals between consecutive observations of discrete- and continuous-time models are equal; it also required that matrices \(\mathbf{a}_c\) and \(\mathbf{Q}_{c,d}\) must be full-rank matrices):</p>

<p>\(\mathbf{Q}_c = \mathbf{Q}_d\)</p>

<p>\(\mathbf{a}_c = \mathbf{R}_d - I(k)\)</p>

<p>\(\mathbf{b}_c = \mathbf{\Sigma}\)</p>

<p>\({\mathbf{f}_1}_c = -\mathbf{a}_c^{-1} \times \mathbf{u}_d\)</p>

<p>\(\mathbf{f}_c = -0.5 \mathbf{b}_d \times \mathbf{Q}^{-1}_d\)</p>

<p>\({\mu_0}_c = {\mu _0}_d - \mathbf{f}_c \times \mathbf{Q_c} \times \mathbf{f}_c^*\)</p>

<p>\(\theta_c = \theta_d\)</p>

<p>where \(k\) is a number of covariates, which is equal to model&#39;s dimension and &#39;*&#39; denotes transpose operation; \(\mathbf{\Sigma}\) is a \(k \times 1\) matrix which contains <code>s.d.</code>s of corresponding residuals  (residuals of a linear regression \(\mathbf{Y}(t+1) = \mathbf{u} + \mathbf{R}\mathbf{Y}(t) + \mathbf{\epsilon}\); <code>s.d.</code> is a standard deviation), \(I(k)\) is an identity \(k \times k\) matrix.</p>

<h3>Model with time-dependent coefficients</h3>

<p>In previous models, we assumed that coefficients is sort of time-dependant: we multiplied them on to \(e^{\theta t}\). In general, this may not be the case [5]. We extend this to a general case, i.e. (we consider one-dimensional case):</p>

<p>\(\mathbf{a(t)} = \mathbf{par}_1 t + \mathbf{par}_2\) - linear function. </p>

<p>The corresponding equations will be equivalent to one-dimensional continuous case described above.</p>

<h4>Example</h4>

<pre><code class="r">library(stpm)
#Data preparation:
n &lt;- 10
data &lt;- simdata_time_dep(N=n)
# Estimation:
opt.par &lt;- spm_time_dep(data, 
                        start = list(a = -0.05, f1 = 80, Q = 2e-08, f = 80, b = 5, mu0 = 0.001), 
                        frm = list(at = &quot;a&quot;, f1t = &quot;f1&quot;, Qt = &quot;Q&quot;, ft = &quot;f&quot;, bt = &quot;b&quot;, mu0t= &quot;mu0&quot;))
opt.par
</code></pre>

<pre><code>## [[1]]
## [[1]]$a
## [1] -0.05368226378
## 
## [[1]]$f1
## [1] 79.75560382
## 
## [[1]]$Q
## [1] 2.32710145e-08
## 
## [[1]]$f
## [1] 99.86302501
## 
## [[1]]$b
## [1] 5.045763731
## 
## [[1]]$mu0
## [1] 0.001249611794
## 
## [[1]]$status
## [1] 5
## 
## [[1]]$LogLik
##           t2 
## -1598.879143 
## 
## [[1]]$objective
## [1] 1598.879106
## 
## [[1]]$message
## [1] &quot;NLOPT_MAXEVAL_REACHED: Optimization stopped because maxeval (above) was reached.&quot;
</code></pre>

<h2>Setting lower and upper boundaries of the model parameters</h2>

<p>Lower and upper boundaries can be set up with parameters \(lb\) and \(ub\), which represents simple numeric vectors. Note: lengths of  \(lb\) and \(ub\) must be the same as the total length of the parameters. Lower and upper boundaries can be set for continuous-time and time-dependent models only.</p>

<h3>Setting lb and ub for continuous-time model</h3>

<h4>One covariate</h4>

<p>Below we show the example of setting up \(lb\) and \(ub\) when we have a single covariate:</p>

<pre><code class="r">library(stpm)
data &lt;- simdata_cont(N=10, ystart = 80, a = -0.1, Q = 1e-06, mu0 = 1e-5, theta = 0.08, f1 = 80, f=80, b=1, dt=1, sd0=5)
ans &lt;- spm_continuous(dat=data,
                      a = -0.1,
                      f1 = 82, 
                      Q = 1.4e-6,
                      f = 77,
                      b = 1,
                      mu0 = 1.6e-5,
                      theta = 0.1,
                      stopifbound = FALSE,
                      lb=c(-0.2, 60, 0.1e-6, 60, 0.1, 0.1e-5, 0.01), 
                      ub=c(0, 140, 5e-06, 140, 3, 5e-5, 0.20))
ans
</code></pre>

<pre><code>## $a
##              [,1]
## [1,] -0.116292299
## 
## $f1
##             [,1]
## [1,] 80.15539366
## 
## $Q
##                 [,1]
## [1,] 4.572970569e-06
## 
## $f
##             [,1]
## [1,] 119.5073441
## 
## $b
##              [,1]
## [1,] 0.9806033097
## 
## $mu0
## [1] 4.379131795e-05
## 
## $theta
## [1] 0.1602225524
## 
## $status
## [1] 5
## 
## $LogLik
## [1] -641.7170314
## 
## $objective
## [1] 641.6456205
## 
## $message
## [1] &quot;NLOPT_MAXEVAL_REACHED: Optimization stopped because maxeval (above) was reached.&quot;
## 
## $limit
## [1] FALSE
## 
## attr(,&quot;class&quot;)
## [1] &quot;spm.continuous&quot;
</code></pre>

<h4>Two covariates</h4>

<p>This is an example for two physiological variables (covariates).</p>

<pre><code class="r">library(stpm)

data &lt;- simdata_cont(N=10, 
                     a=matrix(c(-0.1,  0.001, 0.001, -0.1), nrow = 2, ncol = 2, byrow = T),
                     f1=t(matrix(c(100, 200), nrow = 2, ncol = 1, byrow = F)),
                     Q=matrix(c(1e-06, 1e-7, 1e-7,  1e-06), nrow = 2, ncol = 2, byrow = T),
                     f=t(matrix(c(100, 200), nrow = 2, ncol = 1, byrow = F)),
                     b=matrix(c(1, 2), nrow = 2, ncol = 1, byrow = F),
                     mu0=1e-4,
                     theta=0.08,
                     ystart = c(100,200), sd0=c(5, 10), dt=1)

a.d &lt;- matrix(c(-0.15,  0.002, 0.002, -0.15), nrow = 2, ncol = 2, byrow = T)
f1.d &lt;- t(matrix(c(95, 195), nrow = 2, ncol = 1, byrow = F))
Q.d &lt;- matrix(c(1.2e-06, 1.2e-7, 1.2e-7,  1.2e-06), nrow = 2, ncol = 2, byrow = T)
f.d &lt;- t(matrix(c(105, 205), nrow = 2, ncol = 1, byrow = F))
b.d &lt;- matrix(c(1, 2), nrow = 2, ncol = 1, byrow = F)
mu0.d &lt;- 1.1e-4
theta.d &lt;- 0.07

ans &lt;- spm_continuous(dat=data,
                      a = a.d, 
                      f1 = f1.d,
                      Q = Q.d,
                      f = f.d,
                      b = b.d,
                      mu0 = mu0.d,
                      theta = theta.d,
                      lb=c(-0.5, ifelse(a.d[2,1] &gt; 0, a.d[2,1]-0.5*a.d[2,1], a.d[2,1]+0.5*a.d[2,1]), ifelse(a.d[1,2] &gt; 0, a.d[1,2]-0.5*a.d[1,2], a.d[1,2]+0.5*a.d[1,2]), -0.5,  
                           80, 100, 
                           Q.d[1,1]-0.5*Q.d[1,1], ifelse(Q.d[2,1] &gt; 0, Q.d[2,1]-0.5*Q.d[2,1], Q.d[2,1]+0.5*Q.d[2,1]), ifelse(Q.d[1,2] &gt; 0, Q.d[1,2]-0.5*Q.d[1,2], Q.d[1,2]+0.5*Q.d[1,2]), Q.d[2,2]-0.5*Q.d[2,2],
                           80, 100,
                           0.1, 0.5,
                           0.1e-4,
                           0.01),
                      ub=c(-0.08,  0.002,  0.002, -0.08,  
                           110, 220, 
                           Q.d[1,1]+0.1*Q.d[1,1], ifelse(Q.d[2,1] &gt; 0, Q.d[2,1]+0.1*Q.d[2,1], Q.d[2,1]-0.1*Q.d[2,1]), ifelse(Q.d[1,2] &gt; 0, Q.d[1,2]+0.1*Q.d[1,2], Q.d[1,2]-0.1*Q.d[1,2]), Q.d[2,2]+0.1*Q.d[2,2],
                           110, 220,
                           1.5, 2.5,
                           1.2e-4,
                           0.10))
ans
</code></pre>

<pre><code>## $a
##                 [,1]            [,2]
## [1,] -0.150267163523  0.001692834917
## [2,]  0.001979205983 -0.148012155129
## 
## $f1
##             [,1]
## [1,] 105.2777868
## [2,] 195.2059583
## 
## $Q
##                 [,1]            [,2]
## [1,] 1.302225923e-06 1.305236854e-07
## [2,] 1.299338548e-07 1.285194449e-06
## 
## $f
##             [,1]
## [1,] 107.4474372
## [2,] 210.4295117
## 
## $b
##             [,1]
## [1,] 1.119337586
## [2,] 1.958657445
## 
## $mu0
## [1] 0.0001124533236
## 
## $theta
## [1] 0.073700401
## 
## $status
## [1] 5
## 
## $LogLik
## [1] 1393.406512
## 
## $objective
## [1] -1793.647542
## 
## $message
## [1] &quot;NLOPT_MAXEVAL_REACHED: Optimization stopped because maxeval (above) was reached.&quot;
## 
## $limit
## [1] FALSE
## 
## attr(,&quot;class&quot;)
## [1] &quot;spm.continuous&quot;
</code></pre>

<h3>Setting lb and ub for model with time-dependent coefficients</h3>

<p>This model uses only one covariate, therefore setting-up model parameters is easy:</p>

<pre><code class="r">n &lt;- 10
data &lt;- simdata_time_dep(N=n)
# Estimation:
opt.par &lt;- spm_time_dep(data, start=list(a=-0.05, f1=80, Q=2e-08, f=80, b=5, mu0=0.001), 
                        lb=c(-1, 30, 1e-8, 30, 1, 1e-6), ub=c(0, 120, 5e-8, 130, 10, 1e-2))
opt.par
</code></pre>

<pre><code>## [[1]]
## [[1]]$a
## [1] -0.04279036718
## 
## [[1]]$f1
## [1] 80.38809853
## 
## [[1]]$Q
## [1] 4.081133468e-08
## 
## [[1]]$f
## [1] 129.3747136
## 
## [[1]]$b
## [1] 5.323063228
## 
## [[1]]$mu0
## [1] 0.002656739164
## 
## [[1]]$status
## [1] 5
## 
## [[1]]$LogLik
##           t2 
## -1643.574648 
## 
## [[1]]$objective
## [1] 1643.573964
## 
## [[1]]$message
## [1] &quot;NLOPT_MAXEVAL_REACHED: Optimization stopped because maxeval (above) was reached.&quot;
</code></pre>

<h4>Special case when some model parameter functions are equal to zero</h4>

<p>Imagine a situation when one parameter function you want to be equal to zero: \(f=0\). Let&#39;s emulate this case:</p>

<pre><code class="r">library(stpm)
n &lt;- 10
data &lt;- simdata_time_dep(N=n)
# Estimation:
opt.par &lt;- spm_time_dep(data, frm = list(at=&quot;a&quot;, f1t=&quot;f1&quot;, Qt=&quot;Q&quot;, ft=&quot;0&quot;, bt=&quot;b&quot;, mu0t=&quot;mu0&quot;))
opt.par
</code></pre>

<pre><code>## [[1]]
## [[1]]$a
## [1] -0.0625
## 
## [[1]]$f1
## [1] 79.45644418
## 
## [[1]]$Q
## [1] 1.931394501e-08
## 
## [[1]]$b
## [1] 60
## 
## [[1]]$mu0
## [1] 3.75
## 
## [[1]]$status
## [1] 5
## 
## [[1]]$LogLik
##           t2 
## -5110.202237 
## 
## [[1]]$objective
## [1] 5110.202011
## 
## [[1]]$message
## [1] &quot;NLOPT_MAXEVAL_REACHED: Optimization stopped because maxeval (above) was reached.&quot;
</code></pre>

<p>As you can see, there is no parameter \(f\) in \(opt.par\). This because we set \(f=0\) in \(frm\)!</p>

<p>Then, is you want to set the constraints, you must not specify the starting value (parameter \(start\)) and \(lb\)/\(ub\) for the parameter \(f\) (otherwise, the function raises an error):</p>

<pre><code class="r">n &lt;- 10
data &lt;- simdata_time_dep(N=n)
# Estimation:
opt.par &lt;- spm_time_dep(data, frm = list(at=&quot;a&quot;, f1t=&quot;f1&quot;, Qt=&quot;Q&quot;, ft=&quot;0&quot;, bt=&quot;b&quot;, mu0t=&quot;mu0&quot;), 
                        start=list(a=-0.05, f1=80, Q=2e-08, b=5, mu0=0.001), 
                        lb=c(-1, 30, 1e-8, 1, 1e-6), ub=c(0, 120, 5e-8, 10, 1e-2))
opt.par
</code></pre>

<pre><code>## [[1]]
## [[1]]$a
## [1] -0.06017271551
## 
## [[1]]$f1
## [1] 80.94287005
## 
## [[1]]$Q
## [1] 2.890423641e-08
## 
## [[1]]$b
## [1] 5.02433746
## 
## [[1]]$mu0
## [1] 1.769452053e-06
## 
## [[1]]$status
## [1] 5
## 
## [[1]]$LogLik
##           t2 
## -1686.005887 
## 
## [[1]]$objective
## [1] 1686.005887
## 
## [[1]]$message
## [1] &quot;NLOPT_MAXEVAL_REACHED: Optimization stopped because maxeval (above) was reached.&quot;
</code></pre>

<p>You can do the same manner if you want two or more parameters to be equal to zero.</p>

<h2>Simulation (individual trajectory projection, also known as microsimulations)</h2>

<p>We added one- and multi- dimensional simulation to be able to generate test data for hyphotesis testing. Data,  which can be simulated can be discrete (equal intervals between observations) and continuous (with arbitrary intervals).</p>

<h3>Discrete-time simulation</h3>

<p>The corresponding function is (<code>k</code> - a number of variables(covariates), equal to model&#39;s dimension):</p>

<p><code>simdata_discr(N=100, a=-0.05, f1=80, Q=2e-8, f=80, b=5, mu0=1e-5, theta=0.08, ystart=80, tstart=30, tend=105, dt=1)</code></p>

<p>Here:</p>

<p><code>N</code> - Number of individuals</p>

<p><code>a</code> - A matrix of <code>k</code>x<code>k</code>, which characterize the rate of the adaptive response</p>

<p><code>f1</code> - A particular state, which if a deviation from the normal (or optimal). This is a vector with length of <code>k</code></p>

<p><code>Q</code> - A matrix of <code>k</code> by <code>k</code>, which is a non-negative-definite symmetric matrix</p>

<p><code>f</code> - A vector-function (with length <code>k</code>) of the normal (or optimal) state</p>

<p><code>b</code> - A diffusion coefficient, <code>k</code> by <code>k</code> matrix</p>

<p><code>mu0</code> - mortality at start period of time (baseline hazard)</p>

<p><code>theta</code> - A displacement coefficient of the Gompertz function</p>

<p><code>ystart</code> - A vector with length equal to number of dimensions used, defines starting values of covariates</p>

<p><code>tstart</code> - A number that defines a start time (30 by default). Can be a number (30 by default) or a vector of two numbers: c(a, b) - in this case, starting value of time is simulated via uniform(a,b) distribution.</p>

<p><code>tend</code> - A number, defines a final time (105 by default)</p>

<p><code>dt</code> - A time interval between observations.</p>

<p>This function returns a table with simulated data, as shown in example below:</p>

<pre><code class="r">library(stpm)
data &lt;- simdata_discr(N=10)
head(data)
</code></pre>

<pre><code>##      id xi t1 t2          y1     y1.next
## [1,]  1  0 30 31 80.00000000 87.34722238
## [2,]  1  0 31 32 87.34722238 85.11759517
## [3,]  1  0 32 33 85.11759517 79.29672311
## [4,]  1  0 33 34 79.29672311 87.48167381
## [5,]  1  0 34 35 87.48167381 87.76689405
## [6,]  1  0 35 36 87.76689405 95.51217902
</code></pre>

<h3>Continuous-time simulation</h3>

<p>The corresponding function is (<code>k</code> - a number of variables(covariates), equal to model&#39;s dimension):</p>

<p><code>simdata_cont(N=100, a=-0.05, f1=80, Q=2e-07, f=80, b=5, mu0=2e-05, theta=0.08, ystart=80, tstart=c(30,50), tend=105)</code></p>

<p>Here:</p>

<p><code>N</code> - Number of individuals</p>

<p><code>a</code> - A matrix of <code>k</code>x<code>k</code>, which characterize the rate of the adaptive response</p>

<p><code>f1</code> - A particular state, which if a deviation from the normal (or optimal). This is a vector with length of <code>k</code></p>

<p><code>Q</code> - A matrix of <code>k</code> by <code>k</code>, which is a non-negative-definite symmetric matrix</p>

<p><code>f</code> - A vector-function (with length <code>k</code>) of the normal (or optimal) state</p>

<p><code>b</code> - A diffusion coefficient, <code>k</code> by <code>k</code> matrix</p>

<p><code>mu0</code> - mortality at start period of time (baseline hazard)</p>

<p><code>theta</code> - A displacement coefficient of the Gompertz function</p>

<p><code>ystart</code> - A vector with length equal to number of dimensions used, defines starting values of covariates</p>

<p><code>tstart</code> - A number that defines a start time (30 by default). Can be a number (30 by default) or a vector of two numbers: c(a, b) - in this case, starting value of time is simulated via uniform(a,b) distribution.</p>

<p><code>tend</code> - A number, defines a final time (105 by default)</p>

<p>This function returns a table with simulated data, as shown in example below:</p>

<pre><code class="r">library(stpm)
data &lt;- simdata_cont(N=10)
head(data)
</code></pre>

<pre><code>##      id xi          t1          t2          y1     y1.next
## [1,]  0  0 36.43107032 38.29968027 79.57625150 71.49029902
## [2,]  0  0 38.29968027 40.29015617 71.49029902 67.44194997
## [3,]  0  0 40.29015617 41.31848418 67.44194997 66.96505669
## [4,]  0  0 41.31848418 42.86215009 66.96505669 75.67305088
## [5,]  0  0 42.86215009 44.27234437 75.67305088 71.01233168
## [6,]  0  0 44.27234437 46.11767882 71.01233168 72.86376392
</code></pre>

<h2>SPM with partially observed covariates</h2>

<p>Stochastic Process Model has many applications in analysis of longitudinal biodemographic data. Such data contain various physiological variables (known as covariates). Data can also potentially contain genetic information available for all or a part of participants. Taking advantage from both genetic and non-genetic information can provide future insights into a broad range of processes describing aging-related changes in the organism.</p>

<h3>Method</h3>

<p>In this package, SPM with partially observed covariates is implemented in form of GenSPM (Genetic SPM), presented in 2009 by Arbeev at al [6] and further advanced in [7,8], further elaborates the basic stochastic process model conception by introducing a categorical variable, \(Z\), which may be a specific value of a genetic marker or, in general, any categorical variable. Currently, \(Z\) has two gradations: 0 or 1 in a genetic group of interest, assuming that \(P(Z=1) = p\), \(p \in [0, 1]\), were \(p\) is the proportion of carriers and non-carriers of an allele in a population. Example of longitudinal data with genetic component \(Z\) is provided below.</p>

<pre><code class="r">library(stpm)
data &lt;- sim_pobs(N=10)
head(data)
</code></pre>

<pre><code>##   id xi          t1          t2 Z          y1     y1.next
## 1  0  0 46.21484075 47.18065473 0 80.06802563 79.12983312
## 2  0  0 47.18065473 48.17629579 0 79.12983312 67.15144889
## 3  0  0 48.17629579 49.18202389 0 67.15144889 68.67302305
## 4  0  0 49.18202389 50.16391990 0 68.67302305 67.42697549
## 5  0  0 50.16391990 51.20296804 0 67.42697549 75.94017658
## 6  0  0 51.20296804 52.12334825 0 75.94017658 71.16084719
</code></pre>

<p>In the specification of the SPM described in 2007 paper by Yashin and colleagues [3] the stochastic differential equation describing the age dynamics of a physiological variable (a dynamic component of the model) is:</p>

<p>\(dY(t) = a(Z, t)(Y(t) - f1(Z, t))dt + b(Z, t)dW(t), Y(t = t_0)\)</p>

<p>Here in this equation, \(Y(t)\) is a \(k \times 1\) matrix, where \(k\) is a number of covariates, which is a model dimension) describing the value of a physiological variable at a time (e.g. age) t. \(f_1(Z,t)\) is a \(k \times 1\) matrix that corresponds to the long-term average value of the stochastic process \(Y(t)\), which describes a trajectory of individual variable influenced by different factors represented by a random Wiener process \(W(t)\). The negative feedback coefficient \(a(Z,t)\) (\(k \times k\) matrix) characterizes the rate at which the stochastic process goes to its mean. In research on aging and well-being, \(f_1(Z,t)\) represents the average allostatic trajectory and \(a(t)\) in this case represents the adaptive capacity of the organism. Coefficient \(b(Z,t)\) (\(k \times 1\) matrix) characterizes a strength of the random disturbances from Wiener process \(W(t)\). All of these parameters depend on \(Z\) (a genetic marker having values 1 or 0).
The following function \(\mu(t,Y(t))\) represents a hazard rate:</p>

<p>\(\mu(t,Y(t)) = \mu_0(t) + (Y(t) - f(Z, t))^*Q(Z, t)(Y(t) - f(Z, t))\)</p>

<p>In this equation: \(\mu_0(t)\) is the baseline hazard, which represents a risk when \(Y(t)\) follows its optimal trajectory; f(t) (\(k \times 1\) matrix) represents the optimal trajectory that minimizes the risk and \(Q(Z, t)\) (\(k \times k\) matrix) represents a sensitivity of risk function to deviation from the norm. In general, model coefficients \(a(Z, t)\), \(f1(Z, t)\), \(Q(Z, t)\), \(f(Z, t)\), \(b(Z, t)\) and \(\mu_0(t)\) are time(age)-dependent.
Once we have data, we then can run analysis, i.e. estimate coefficients (they are assumed to be time-independent and data here is simulated):</p>

<pre><code class="r">library(stpm)
#Generating data:
data &lt;- sim_pobs(N=10)
head(data)
</code></pre>

<pre><code>##   id xi          t1          t2 Z          y1     y1.next
## 1  0  0 37.97500131 38.99825208 1 80.51068101 74.91504353
## 2  0  0 38.99825208 39.91311375 1 74.91504353 71.40949561
## 3  0  0 39.91311375 40.94929879 1 71.40949561 71.80343219
## 4  0  0 40.94929879 41.91448130 1 71.80343219 73.26982817
## 5  0  0 41.91448130 42.99088991 1 73.26982817 66.48055609
## 6  0  0 42.99088991 43.90924022 1 66.48055609 69.72237394
</code></pre>

<pre><code class="r">#Parameters estimation:
pars &lt;- spm_pobs(x=data)
</code></pre>

<pre><code>## Parameter aL achieved lower/upper bound.
## -0.011
</code></pre>

<pre><code class="r">pars
</code></pre>

<pre><code>## $aH
##               [,1]
## [1,] -0.0547561709
## 
## $aL
##        [,1]
## [1,] -0.011
## 
## $f1H
##             [,1]
## [1,] 54.27369526
## 
## $f1L
##             [,1]
## [1,] 87.19371346
## 
## $QH
##                 [,1]
## [1,] 2.064626511e-08
## 
## $QL
##                 [,1]
## [1,] 2.491204388e-08
## 
## $fH
##             [,1]
## [1,] 56.42563216
## 
## $fL
##             [,1]
## [1,] 83.17287757
## 
## $bH
##             [,1]
## [1,] 4.245732019
## 
## $bL
##             [,1]
## [1,] 5.242038017
## 
## $mu0H
## [1] 8.762004516e-06
## 
## $mu0L
## [1] 9.076253972e-06
## 
## $thetaH
## [1] 0.07259778047
## 
## $thetaL
## [1] 0.09002705978
## 
## $p
## [1] 0.239151311
## 
## $limit
## [1] TRUE
## 
## attr(,&quot;class&quot;)
## [1] &quot;pobs.spm&quot;
</code></pre>

<p>Here \textbf{H} and \textbf{L} represents parameters when \(Z\) = 1 (<strong>H</strong>) and 0 (<strong>L</strong>).</p>

<p>###Joint analysis of two datasets: first dataset with genetic and second dataset with non-genetic component</p>

<pre><code class="r">library(stpm)
data.genetic &lt;- sim_pobs(N=5, mode=&#39;observed&#39;)
head(data.genetic)
</code></pre>

<pre><code>##   id xi          t1          t2 Z          y1     y1.next
## 1  0  0 50.10586314 51.09057508 1 80.61553762 67.94947454
## 2  0  0 51.09057508 52.03020721 1 67.94947454 72.34375310
## 3  0  0 52.03020721 53.10323881 1 72.34375310 67.82121326
## 4  0  0 53.10323881 54.03449571 1 67.82121326 63.63582178
## 5  0  0 54.03449571 55.05812251 1 63.63582178 66.62148863
## 6  0  0 55.05812251 55.96768428 1 66.62148863 65.02677953
</code></pre>

<pre><code class="r">data.nongenetic &lt;- sim_pobs(N=10, mode=&#39;unobserved&#39;)
head(data.nongenetic)
</code></pre>

<pre><code>##   id xi          t1          t2          y1     y1.next
## 1  0  0 71.73174544 72.65900771 78.76331893 76.00772680
## 2  0  0 72.65900771 73.56585982 76.00772680 82.89538357
## 3  0  0 73.56585982 74.50569965 82.89538357 75.00296026
## 4  0  0 74.50569965 75.45945866 75.00296026 75.84904279
## 5  0  0 75.45945866 76.52682046 75.84904279 84.12721888
## 6  0  0 76.52682046 77.50133019 84.12721888 83.05148365
</code></pre>

<pre><code class="r">#Parameters estimation:
pars &lt;- spm_pobs(x=data.genetic, y = data.nongenetic, mode=&#39;combined&#39;)
</code></pre>

<pre><code>## Parameter mu0L achieved lower/upper bound.
## 9e-06
</code></pre>

<pre><code class="r">pars
</code></pre>

<pre><code>## $aH
##                [,1]
## [1,] -0.01165824172
## 
## $aL
##                 [,1]
## [1,] -0.004074567432
## 
## $f1H
##             [,1]
## [1,] 54.19897487
## 
## $f1L
##             [,1]
## [1,] 80.13089567
## 
## $QH
##                 [,1]
## [1,] 1.298777912e-09
## 
## $QL
##                 [,1]
## [1,] 2.604321996e-08
## 
## $fH
##             [,1]
## [1,] 55.32975011
## 
## $fL
##             [,1]
## [1,] 72.60615764
## 
## $bH
##             [,1]
## [1,] 4.394069242
## 
## $bL
##           [,1]
## [1,] 5.1702684
## 
## $mu0H
## [1] 7.409298248e-06
## 
## $mu0L
## [1] 9e-06
## 
## $thetaH
## [1] 0.07246416376
## 
## $thetaL
## [1] 0.09001572997
## 
## $p
## [1] 0.2320044975
## 
## $limit
## [1] TRUE
## 
## attr(,&quot;class&quot;)
## [1] &quot;pobs.spm&quot;
</code></pre>

<p>Here mode &#39;observed&#39; is used for simlation of data with genetic component \(Z\) and &#39;unobserved&#39; - without genetic component.</p>

<h2>References</h2>

<p>[1] Woodbury M.A., Manton K.G., Random-Walk of Human Mortality and Aging. Theoretical Population Biology, 1977 11:37-48.</p>

<p>[2] Yashin, A.I., Manton K.G., Vaupel J.W. Mortality and aging in a heterogeneous population: a stochastic process model with observed and unobserved varia-bles. Theor Pop Biology, 1985 27.</p>

<p>[3] Yashin, A.I. et al. Stochastic model for analysis of longitudinal data on aging and mortality. Mathematical Biosciences, 2007 208(2) 538-551.</p>

<p>[4] Akushevich I., Kulminski A. and Manton K.: Life tables with covariates: Dynamic model for Nonlinear Analysis of Longitudinal Data. 2005. Mathematical Popu-lation Studies, 12(2), pp.: 51-80.</p>

<p>[5] Yashin, A. et al.  Health decline, aging and mortality: how are they related? Biogerontology, 2007 8(3), 291-302.</p>

<p>[6] Arbeev, K.G., Akushevich, I., Kulminski, A.M., Arbeeva, L.S., Akushevich, L., Ukraintseva, S.V., Culminskaya, I.V., Yashin, A.I.: Genetic model for longitudinal studies of aging, health, and longevity and its potential application to incomplete data. Journal of Theoretical Biology 258(1), 103{111 (2009).</p>

<p>[7] Arbeev K.G, Akushevich I., Kulminski A.M., Ukraintseva S.V., Yashin A.I., Joint Analyses of Longitudinal and Time-to-Event Data in Research on Aging: Implications for Predicting Health and Survival, Front Public Health. 2014 Nov 6;2:228. doi: 10.3389/fpubh.2014.00228</p>

<p>[8] Arbeev K., Arbeeva L., Akushevich I., Kulminski A., Ukraintseva S., Yashin A., Latent Class and Genetic Stochastic Process Models: Implications for Analyses of Longitudinal Data on Aging, Health, and Longevity, JSM-2015, Seattle, WA.</p>

</body>

</html>
